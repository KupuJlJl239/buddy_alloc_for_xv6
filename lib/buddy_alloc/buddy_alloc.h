#pragma once

/*
Реализация buddy-аллокатора на языке C (см. https://en.wikipedia.org/wiki/Buddy_memory_allocation), написанная для xv6.

Типы данных:
buddy_free_block_t, buddy_list_t      не нужны для внешнего использования, хранят метаинформацию
buddy_allocator_t               тип, представляющий аллокатор

Функции:
lib_buddy_init      инициализирует buddy_allocator_t
lib_buddy_alloc     выделение памяти
lib_buddy_free      освобождение памяти
*/



/*
Терминология:
    страница, page          -- наименьший по размеру кусок памяти, который может быть выделен
    блок                    -- кусок памяти, который может быть выделен; в каждом всегда ровно степень двойки страниц
    уровень блока, level    -- логарифм от числа страниц в блоке; если level = 0, то блок - это страница
    свободный блок          -- ни одна из страниц которого не используется в данный момент
    выделенный блок         -- блок, зарезервированный ОДНИМ выделением, т.е. вызовом lib_buddy_alloc
*/





#ifdef XV6
    #include "kernel/types.h"
    typedef uint64 uint64_t;
#else
    #include <stdint.h>
#endif


/*
Все свободные блоки одного уровня соединены в двусвязный список.
Итого есть по одному списку для каждого уровня.
В начале каждого свободного блока лежит узел списка.
Свободные блоки в каждом списке расположены не обязательно по порядку.
*/

struct buddy_list;

// Лежит в начале каждого свободного блока
typedef struct buddy_free_block{
    struct buddy_free_block* next;
    struct buddy_free_block* prev;
    struct buddy_list* list;
    int level;
} buddy_free_block_t;

// Объединяет все свободные блоки уровня level
typedef struct buddy_list{
    buddy_free_block_t head;
    uint64_t len;   // длина списков = число свободных блоков уровня level
} buddy_list_t;



enum BuddyTableState{
    BUDDY_NOTHING = -1,
};



/*
В первых нескольких страницах хранятся метаданные:
    - списки свободных блоков (поле lists)
    - таблица состояний (поле state_table)
Остальные страницы рабочие.

Общая логика такая: для выделений и быстрого поиска свободных
кусков используем списки lists, а для освобождений и проверки
состояния блока используем state_table. 
В результате все операции работают за константу.

Таблица состояний позволяет по данному номеру страницы определить, 
выделен ли блок с началом в этой странице, и если это так, то сколько же страниц в этом блоке.
У первой рабочей страницы номер 0
Всего рабочих страниц pages, и такой же размер массива state_table.
Пусть номер данной страницы равен n.
Тогда есть такие варианты: 
    1) state_table[n] == BUDDY_NOTHING (= -1)  =>  ни один выделенный блок не начинается в этой странице, 
    2) state_table[n] == lvl >= 0  =>  в этой странице начинается выделенный блок уровня lvl
*/
typedef struct {
    int levels;         // количество используемых уровней блоков
    uint64_t pgsize;    // размер страницы

    buddy_list_t* lists;    // массив списков свободных блоков, имеет размер levels; указывает также на начало метаданных
    char* state_table;      // таблица состояний, имеет размер pages

    uint64_t pages;  // количество рабочих страниц
    void* data;      // указатель на первую рабочую страницу
} buddy_allocator_t;




// Возвращает -1, если метаданные не влезли в память (бывает если levels велико или pgsize мало), иначе 0
int lib_buddy_init(
    buddy_allocator_t* mem, 
    int levels,         // количество уровней в аллокаторе
    uint64_t pgsize,    // размер страницы
    uint64_t pages,     // число страниц
    void* ptr           // распределяемые ресурсы
);

// Аллоцирует блок, состоящий из pages страниц; pages обязана быть степенью двойки. При какой-либо ошибке возвращает нулевой указатель
void* lib_buddy_alloc(buddy_allocator_t* mem, uint64_t pages);

// Освобождает ранее выделенный блок. Если не удалось - паникует!
void lib_buddy_free(buddy_allocator_t* mem, void* addr);

